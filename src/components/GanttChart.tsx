import {  ChangeEvent,  FormEvent,  forwardRef,  useCallback,  useEffect,  useImperativeHandle,  useMemo,  useRef,  useState,} from "react";import { Project, Task, TaskStatus } from "../types";type TaskFormState = {  projectId: string;  name: string;  description: string;  startDate: string;  dueDate: string;  status: TaskStatus;  dependencies: string[];};type GanttChartProps = {  projects: Project[];  tasks: Task[];  selectedProjectId: string | null;  onCreateTask: (input: TaskFormState) => void;  onUpdateTask: (taskId: string, input: TaskFormState) => void;  showHeader?: boolean;  showControls?: boolean;  dayWidth?: number;  onDayWidthChange?: (value: number) => void;  statusFilter?: StatusFilter;  onStatusFilterChange?: (value: StatusFilter) => void;  selectedTaskId?: string;  onSelectedTaskIdChange?: (taskId: string) => void;  className?: string;};export type StatusFilter = "all" | TaskStatus;export type GanttChartHandle = {  openCreateTask: () => void;  openEditTask: (taskId?: string) => void;  scrollToToday: () => void;};const DAY_MS = 86_400_000;const DEFAULT_DAY_WIDTH = 64;const MIN_TIMELINE_DAYS = 21;const BUFFER_DAYS = 3;const statusLabel: Record<TaskStatus, string> = {  todo: "Not started",  "in-progress": "In progress",  done: "Completed",};const statusClass: Record<TaskStatus, string> = {  todo: "gantt__bar--todo",  "in-progress": "gantt__bar--in-progress",  done: "gantt__bar--done",};const toISODate = (date: Date) => {  const copy = new Date(date);  copy.setHours(0, 0, 0, 0);  return copy.toISOString().slice(0, 10);};const parseISO = (value: string) => new Date(`${value}T00:00:00`);const diffInDays = (start: Date, end: Date) => Math.max(0, Math.round((end.getTime() - start.getTime()) / DAY_MS));const createDefaultForm = (projectId: string | null): TaskFormState => {  const today = new Date();  const due = new Date(today);  due.setDate(today.getDate() + 3);  return {    projectId: projectId ?? "",    name: "",    description: "",    startDate: toISODate(today),    dueDate: toISODate(due),    status: "todo",    dependencies: [],  };};const formatDayLabel = (date: Date) =>  date.toLocaleDateString(undefined, {    month: "short",    day: "numeric",  });const GanttChart = forwardRef<GanttChartHandle, GanttChartProps>(  (    {      projects,      tasks,      selectedProjectId,      onCreateTask,      onUpdateTask,      showHeader = true,      showControls = true,      dayWidth: dayWidthProp,      onDayWidthChange,      statusFilter: statusFilterProp,      onStatusFilterChange,      selectedTaskId: selectedTaskIdProp,      onSelectedTaskIdChange,      className = "",    },    ref,  ) => {    const timelineRef = useRef<HTMLDivElement>(null);    const [internalDayWidth, setInternalDayWidth] = useState<number>(dayWidthProp ?? DEFAULT_DAY_WIDTH);    const [statusFilter, setStatusFilter] = useState<StatusFilter>(statusFilterProp ?? "all");    const [selectedTaskId, setSelectedTaskId] = useState<string>(selectedTaskIdProp ?? "");    const [isModalOpen, setIsModalOpen] = useState(false);    const [editingTaskId, setEditingTaskId] = useState<string | null>(null);    const [taskForm, setTaskForm] = useState<TaskFormState>(createDefaultForm(selectedProjectId));    useEffect(() => {      if (dayWidthProp !== undefined) {        setInternalDayWidth(dayWidthProp);      }    }, [dayWidthProp]);    useEffect(() => {      if (statusFilterProp !== undefined) {        setStatusFilter(statusFilterProp);      }    }, [statusFilterProp]);    useEffect(() => {      if (selectedTaskIdProp !== undefined) {        setSelectedTaskId(selectedTaskIdProp);      }    }, [selectedTaskIdProp]);    const visibleTasks = useMemo(() => {      const scoped = selectedProjectId ? tasks.filter((task) => task.projectId === selectedProjectId) : tasks;      if (statusFilter === "all") {        return scoped;      }      return scoped.filter((task) => task.status === statusFilter);    }, [tasks, selectedProjectId, statusFilter]);    const timelineRange = useMemo(() => {      if (visibleTasks.length === 0) {        const today = new Date();        const end = new Date(today);        end.setDate(today.getDate() + MIN_TIMELINE_DAYS);        return { start: today, end };      }      const starts = visibleTasks.map((t) => parseISO(t.startDate).getTime());      const ends = visibleTasks.map((t) => parseISO(t.dueDate).getTime());      const min = Math.min(...starts);      const max = Math.max(...ends);      const start = new Date(min);      start.setDate(start.getDate() - BUFFER_DAYS);      const end = new Date(max);      end.setDate(end.getDate() + BUFFER_DAYS);      if (diffInDays(start, end) < MIN_TIMELINE_DAYS) {        end.setDate(start.getDate() + MIN_TIMELINE_DAYS);      }      return { start, end };    }, [visibleTasks]);    const totalDays = diffInDays(timelineRange.start, timelineRange.end) + 1;    const timelineWidth = totalDays * internalDayWidth;    const metrics = useMemo(() => {      const total = visibleTasks.length;      const inProgress = visibleTasks.filter((t) => t.status === "in-progress").length;      const done = visibleTasks.filter((t) => t.status === "done").length;      const overdue = visibleTasks.filter((t) => parseISO(t.dueDate) < new Date() && t.status !== "done").length;      return { total, inProgress, done, overdue };    }, [visibleTasks]);    const openModal = useCallback(      (task?: Task) => {        if (task) {          setTaskForm({            projectId: task.projectId,            name: task.name,            description: task.description ?? "",            startDate: task.startDate,            dueDate: task.dueDate,            status: task.status,            dependencies: task.dependencies ?? [],          });          setEditingTaskId(task.id);        } else {          setTaskForm(createDefaultForm(selectedProjectId));          setEditingTaskId(null);        }        setIsModalOpen(true);      },      [selectedProjectId],    );    const closeModal = () => {      setIsModalOpen(false);      setEditingTaskId(null);    };    const handleSubmit = (event: FormEvent) => {      event.preventDefault();      const payload: TaskFormState = {        ...taskForm,        dependencies: taskForm.dependencies.filter(Boolean),      };      if (editingTaskId) {        onUpdateTask(editingTaskId, payload);      } else {        onCreateTask(payload);      }      closeModal();    };    const handleDependencyChange = (options: HTMLCollectionOf<HTMLOptionElement>) => {      const values: string[] = [];      Array.from(options).forEach((option) => {        if (option.selected) {          values.push(option.value);        }      });      setTaskForm((prev) => ({ ...prev, dependencies: values }));    };    const handleSelectTask = (taskId: string) => {      setSelectedTaskId(taskId);      onSelectedTaskIdChange?.(taskId);    };    const scrollToToday = useCallback(() => {      const container = timelineRef.current;      if (!container) return;      const today = toISODate(new Date());      const targetX = (diffInDays(timelineRange.start, parseISO(today)) + 0.5) * internalDayWidth;      container.scrollTo({ left: Math.max(targetX - container.clientWidth / 2, 0), behavior: "smooth" });    }, [timelineRange.start, internalDayWidth]);    useImperativeHandle(ref, () => ({      openCreateTask: () => openModal(),      openEditTask: (taskId?: string) => {        if (!taskId) {          openModal();          return;        }        const task = tasks.find((t) => t.id === taskId);        if (task) openModal(task);      },      scrollToToday,    }));    const handleDayWidthChange = (value: number) => {      setInternalDayWidth(value);      onDayWidthChange?.(value);    };    const handleStatusFilterChange = (value: StatusFilter) => {      setStatusFilter(value);      onStatusFilterChange?.(value);    };    const renderTimelineHeader = () => (      <div className="gantt__table-header" style={{ gridTemplateColumns: `200px repeat(${totalDays}, ${internalDayWidth}px)` }}>        <div className="gantt__head-label">Timeline</div>        {Array.from({ length: totalDays }).map((_, index) => {          const date = new Date(timelineRange.start);          date.setDate(timelineRange.start.getDate() + index);          return (            <div key={index} className="gantt__head-day">              {formatDayLabel(date)}            </div>          );        })}      </div>    );    const renderBars = () =>      visibleTasks.map((task) => {        const start = parseISO(task.startDate);        const end = parseISO(task.dueDate);        const offset = diffInDays(timelineRange.start, start) * internalDayWidth;        const width = Math.max((diffInDays(start, end) + 1) * internalDayWidth, internalDayWidth * 0.6);        return (          <div key={task.id} className="gantt__table-row" style={{ gridTemplateColumns: `200px repeat(${totalDays}, ${internalDayWidth}px)` }}>            <div className="gantt__row-label">              <strong>{task.name}</strong>              <small>{statusLabel[task.status]}</small>            </div>            <div className="gantt__row-track">              <div                className={`gantt__bar ${statusClass[task.status]}`}                style={{ marginLeft: offset, width }}                onClick={() => {                  handleSelectTask(task.id);                  openModal(task);                }}                role="button"                tabIndex={0}              >                <div className="gantt__bar-progress" style={{ width: `${task.status === "done" ? 100 : task.status === "in-progress" ? 50 : 10}%` }} />                <div className="gantt__bar-content">                  <span>{task.name}</span>                  <span>{statusLabel[task.status]}</span>                </div>              </div>            </div>          </div>        );      });    const selectedTask = selectedTaskId ? tasks.find((t) => t.id === selectedTaskId) ?? null : null;    return (      <section className={`gantt ${className}`}>        {showHeader && (          <div className="gantt__header">            <div className="gantt__title">              <h2>Project schedule</h2>              <p>Plan, visualize, and adjust tasks in one place.</p>            </div>            <div className="gantt__metrics">              <div className="gantt__metric">                <span>Tasks</span>                <strong>{metrics.total}</strong>              </div>              <div className="gantt__metric">                <span>In progress</span>                <strong>{metrics.inProgress}</strong>              </div>              <div className={`gantt__metric${metrics.overdue > 0 ? " gantt__metric--alert" : ""}`}>                <span>Overdue</span>                <strong>{metrics.overdue}</strong>              </div>            </div>          </div>        )}        {showControls && (          <div className="gantt__controls">            <div className="gantt__filters" role="tablist" aria-label="Task status">              {(["all", "todo", "in-progress", "done"] as StatusFilter[]).map((value) => (                <button                  key={value}                  type="button"                  className={`gantt__chip${statusFilter === value ? " is-active" : ""}`}                  onClick={() => handleStatusFilterChange(value)}                  aria-pressed={statusFilter === value}                >                  {value === "all" ? "All tasks" : statusLabel[value as TaskStatus]}                </button>              ))}            </div>            <div className="gantt__actions">              <label className="gantt__slider">                <span>Zoom</span>                <input                  type="range"                  min={40}                  max={120}                  step={4}                  value={internalDayWidth}                  onChange={(event: ChangeEvent<HTMLInputElement>) => handleDayWidthChange(Number(event.target.value))}                />              </label>              <div className="gantt__select-group">                <button type="button" className="gantt__primary" onClick={() => openModal()}>                  New task                </button>                <button type="button" onClick={scrollToToday}>                  Jump to today                </button>              </div>            </div>          </div>        )}        <div className="gantt__viewport" ref={timelineRef}>          <div className="gantt__table" style={{ width: `${timelineWidth + 200}px` }}>            {renderTimelineHeader()}            <div className="gantt__table-body">              {visibleTasks.length === 0 ? (                <div className="gantt__table-empty" style={{ width: `${timelineWidth}px` }}>                  No tasks to display.                </div>              ) : (                renderBars()              )}            </div>          </div>        </div>        {selectedTask && (          <div className="gantt__actions" aria-live="polite">            <span>Selected:</span>            <strong>{selectedTask.name}</strong>            <button type="button" onClick={() => openModal(selectedTask)}>              Edit            </button>          </div>        )}        {isModalOpen && (          <div className="modal">            <div className="modal__backdrop" onClick={closeModal} />            <div className="modal__dialog" role="dialog" aria-modal="true">              <form className="modal__form" onSubmit={handleSubmit}>                <header className="modal__header">                  <h3>{editingTaskId ? "Edit task" : "Add task"}</h3>                  <button type="button" className="modal__close" onClick={closeModal} aria-label="Close task form">                    &times;                  </button>                </header>                <label>                  Project                  <select                    value={taskForm.projectId}                    onChange={(event) => setTaskForm((prev) => ({ ...prev, projectId: event.target.value }))}                    required                  >                    <option value="" disabled>                      Select a project                    </option>                    {projects.map((project) => (                      <option key={project.id} value={project.id}>                        {project.name}                      </option>                    ))}                  </select>                </label>                <label>                  Name                  <input                    type="text"                    value={taskForm.name}                    onChange={(event) => setTaskForm((prev) => ({ ...prev, name: event.target.value }))}                    placeholder="Task title"                    required                  />                </label>                <label>                  Description                  <textarea                    value={taskForm.description}                    onChange={(event) => setTaskForm((prev) => ({ ...prev, description: event.target.value }))}                    placeholder="Task details"                    rows={3}                  />                </label>                <div className="modal__grid">                  <label>                    Start                    <input                      type="date"                      value={taskForm.startDate}                      onChange={(event) => setTaskForm((prev) => ({ ...prev, startDate: event.target.value }))}                      required                    />                  </label>                  <label>                    Due                    <input                      type="date"                      value={taskForm.dueDate}                      onChange={(event) => setTaskForm((prev) => ({ ...prev, dueDate: event.target.value }))}                      required                    />                  </label>                </div>                <label>                  Status                  <select                    value={taskForm.status}                    onChange={(event) => setTaskForm((prev) => ({ ...prev, status: event.target.value as TaskStatus }))}                  >                    <option value="todo">To do</option>                    <option value="in-progress">In progress</option>                    <option value="done">Done</option>                  </select>                </label>                <label>                  Dependencies                  <select                    multiple                    value={taskForm.dependencies}                    onChange={(event) => handleDependencyChange(event.target.selectedOptions)}                  >                    {tasks                      .filter((task) => task.projectId === taskForm.projectId && task.id !== editingTaskId)                      .map((task) => (                        <option key={task.id} value={task.id}>                          {task.name}                        </option>                      ))}                  </select>                </label>                <div className="modal__actions">                  <button type="button" className="modal__secondary" onClick={closeModal}>                    Cancel                  </button>                  <button type="submit" className="modal__primary">                    {editingTaskId ? "Save changes" : "Create task"}                  </button>                </div>              </form>            </div>          </div>        )}      </section>    );  },);export default GanttChart;